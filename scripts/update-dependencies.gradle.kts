import com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask
import groovy.json.JsonSlurper

// Configure the ben-manes dependencyUpdates task to output JSON
tasks.withType<DependencyUpdatesTask> {
    outputFormatter = "json"

    // Only suggest stable versions (reject alpha, beta, rc, etc.)
    rejectVersionIf {
        val dominated = listOf("alpha", "beta", "rc", "cr", "m", "preview", "dev")
        dominated.any { qualifier ->
            candidate.version.lowercase().contains(qualifier)
        }
    }
}

tasks.register("updateDependencies") {
    dependsOn("dependencyUpdates")

    doLast {
        // Keys in [versions] that should never be auto-updated
        val excludeKeys = setOf("popular-movies-version", "epoxy", "androidGradlePlugin", "kotlin")

        // Read the JSON report generated by dependencyUpdates
        val reportFile = file("build/dependencyUpdates/report.json")
        if (!reportFile.exists()) {
            println("Dependency updates report not found at ${reportFile.path}")
            return@doLast
        }

        @Suppress("UNCHECKED_CAST")
        val json = JsonSlurper().parseText(reportFile.readText()) as Map<String, Any>
        @Suppress("UNCHECKED_CAST")
        val outdated = json["outdated"] as? Map<String, Any> ?: run {
            println("No outdated dependencies section found in report")
            return@doLast
        }
        @Suppress("UNCHECKED_CAST")
        val dependencies = outdated["dependencies"] as? List<Map<String, Any>> ?: run {
            println("No outdated dependencies found")
            return@doLast
        }

        // Build a map of group:name -> latest available version
        val availableUpdates = mutableMapOf<String, String>()
        for (dep in dependencies) {
            val group = dep["group"] as? String ?: continue
            val name = dep["name"] as? String ?: continue
            @Suppress("UNCHECKED_CAST")
            val available = dep["available"] as? Map<String, Any> ?: continue
            val newVersion = (available["milestone"] ?: available["minor"]
                ?: available["patch"] ?: available["major"]) as? String ?: continue
            availableUpdates["$group:$name"] = newVersion
        }

        if (availableUpdates.isEmpty()) {
            println("All dependencies are up to date")
            return@doLast
        }

        // Read the TOML catalog
        val tomlFile = project.file("gradle/libs.versions.toml")
        val tomlContent = tomlFile.readText()
        val tomlLines = tomlContent.lines().toMutableList()

        // Parse [libraries] to map version.ref -> group:name coordinates
        val versionRefToCoordinates = mutableMapOf<String, MutableSet<String>>()
        val libraryRegex = """^\s*[\w\-]+\s*=\s*\{.*version\.ref\s*=\s*"([\w\-]+)".*\}""".toRegex()
        val groupRegex = """(?:module\s*=\s*"([^"]+:[^"]+)"|group\s*=\s*"([^"]+)".*name\s*=\s*"([^"]+)")""".toRegex()

        for (line in tomlLines) {
            val refMatch = libraryRegex.find(line) ?: continue
            val versionRef = refMatch.groupValues[1]
            val coordMatch = groupRegex.find(line) ?: continue
            val coordinate = if (coordMatch.groupValues[1].isNotEmpty()) {
                coordMatch.groupValues[1]
            } else {
                "${coordMatch.groupValues[2]}:${coordMatch.groupValues[3]}"
            }
            versionRefToCoordinates.getOrPut(versionRef) { mutableSetOf() }.add(coordinate)
        }

        // Determine which version keys to update and to what version
        val versionUpdates = mutableMapOf<String, String>()
        for ((versionKey, coordinates) in versionRefToCoordinates) {
            if (versionKey in excludeKeys) continue
            for (coord in coordinates) {
                val newVersion = availableUpdates[coord]
                if (newVersion != null) {
                    versionUpdates[versionKey] = newVersion
                    break
                }
            }
        }

        if (versionUpdates.isEmpty()) {
            println("No version updates to apply (after exclusions)")
            return@doLast
        }

        // Apply updates to the [versions] section of the TOML
        val versionLineRegex = """^(\s*)([\w\-]+)(\s*=\s*")([^"]+)(".*)$""".toRegex()
        val updatedLines = tomlLines.map { line ->
            val match = versionLineRegex.matchEntire(line)
            if (match != null) {
                val key = match.groupValues[2]
                val newVersion = versionUpdates[key]
                if (newVersion != null) {
                    val oldVersion = match.groupValues[4]
                    println("  $key: $oldVersion -> $newVersion")
                    "${match.groupValues[1]}${key}${match.groupValues[3]}${newVersion}${match.groupValues[5]}"
                } else {
                    line
                }
            } else {
                line
            }
        }

        tomlFile.writeText(updatedLines.joinToString("\n"))
        println("Dependencies updated successfully (${versionUpdates.size} versions changed)")
    }
}
